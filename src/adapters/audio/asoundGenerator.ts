import { writeFile, readFile } from 'node:fs/promises';
import { createLogger } from '@/shared/logging/logger';
import {
  AudioDeviceScanner,
  type AudioDevice,
  type VirtualAlsaDevice,
} from './audioDeviceScanner';

const log = createLogger('Audio', 'AsoundGenerator');

const ASOUND_CONF = '/etc/asound.conf';
const MARKER = '# Auto-generated by Audio2Lox';

const CH_LABELS = [
  'Front-Left',
  'Front-Right',
  'Rear-Left',
  'Rear-Right',
  'Center',
  'LFE-Sub',
  'Side-Left',
  'Side-Right',
];

/**
 * Generate /etc/asound.conf with per-channel virtual ALSA devices
 * for every playback card detected by the system.
 *
 * Only overwrites the file if it was previously generated by us
 * (contains our marker comment) or does not exist yet.
 */
export async function generateAsoundConf(
  scanner: AudioDeviceScanner,
): Promise<VirtualAlsaDevice[]> {
  // Check if file exists and was NOT generated by us
  try {
    const existing = await readFile(ASOUND_CONF, 'utf-8');
    if (existing.length > 0 && !existing.includes(MARKER)) {
      log.info(
        'Existing /etc/asound.conf was not generated by Audio2Lox – skipping',
      );
      return scanner.getVirtualDevices();
    }
  } catch {
    // File doesn't exist – we'll create it
  }

  const devices = await scanner.getDevices();
  const playbackCards = devices.filter((d) =>
    d.channels.some((ch) => ch.direction === 'playback'),
  );

  if (playbackCards.length === 0) {
    log.warn('No playback devices found – not generating asound.conf');
    return [];
  }

  const { content, virtualDevices } = buildAsoundConf(playbackCards);

  try {
    await writeFile(ASOUND_CONF, content, 'utf-8');
    log.info('Generated /etc/asound.conf', {
      cards: playbackCards.length,
      monoOutputs: virtualDevices.filter((v) => v.mode === 'mono').length,
      stereoOutputs: virtualDevices.filter((v) => v.mode === 'stereo').length,
    });
  } catch (err) {
    log.error('Failed to write /etc/asound.conf', { error: String(err) });
  }

  return virtualDevices;
}

/**
 * Build the asound.conf content string and collect virtual device metadata.
 */
function buildAsoundConf(cards: AudioDevice[]): {
  content: string;
  virtualDevices: VirtualAlsaDevice[];
} {
  const lines: string[] = [];
  const virtualDevices: VirtualAlsaDevice[] = [];
  let ipcKey = 1024;

  lines.push(MARKER);
  lines.push(
    '# DO NOT EDIT – this file is regenerated on every Audio2Lox start.',
    '# To customise, create /etc/asound.local.conf and it will be included.',
    '#',
    '',
  );

  for (const card of cards) {
    const playbackChannels = card.channels.filter(
      (ch) => ch.direction === 'playback',
    );
    if (playbackChannels.length === 0) continue;

    // Use first playback device to determine hw id
    const firstPb = playbackChannels[0];
    const hwDev = firstPb.id; // e.g. "hw:0,0"
    const maxCh = card.maxChannels || 2;

    const prefix =
      firstPb.deviceId === 0
        ? `card${card.cardId}`
        : `card${card.cardId}d${firstPb.deviceId}`;

    lines.push(
      `# ${'='.repeat(72)}`,
      `# Card ${card.cardId}: ${card.longName} (${hwDev}, ${maxCh} channels)`,
      `# ${'='.repeat(72)}`,
      '',
    );

    // dmix for shared access
    lines.push(
      `pcm.${prefix}_dmix {`,
      `    type dmix`,
      `    ipc_key ${ipcKey}`,
      `    ipc_perm 0666`,
      `    slave {`,
      `        pcm "${hwDev}"`,
      `        rate 48000`,
      `        channels ${maxCh}`,
      `        period_size 1024`,
      `        buffer_size 4096`,
      `    }`,
      `}`,
      '',
    );
    ipcKey++;

    // Mono channels
    for (let ch = 0; ch < maxCh; ch++) {
      const label = ch < CH_LABELS.length ? CH_LABELS[ch] : `Ch${ch}`;
      const devId = `${prefix}_ch${ch}`;

      lines.push(
        `# ${devId}: ${card.longName} → Channel ${ch} (${label})`,
        `pcm.${devId} {`,
        `    type route`,
        `    slave { pcm "${prefix}_dmix"; channels ${maxCh} }`,
        `    ttable { 0.${ch} 1.0 }`,
        `}`,
        '',
      );

      virtualDevices.push({
        id: devId,
        mode: 'mono',
        cardId: card.cardId,
        outputChannels: [ch],
        label: `Card ${card.cardId} → Ch ${ch} (${label})`,
      });
    }

    // Stereo pairs
    for (let ch = 0; ch < maxCh - 1; ch += 2) {
      const ch2 = ch + 1;
      const labelA = ch < CH_LABELS.length ? CH_LABELS[ch] : `Ch${ch}`;
      const labelB = ch2 < CH_LABELS.length ? CH_LABELS[ch2] : `Ch${ch2}`;
      const devId = `${prefix}_stereo${ch}${ch2}`;

      lines.push(
        `# ${devId}: ${card.longName} → Channels ${ch}+${ch2} (${labelA}/${labelB})`,
        `pcm.${devId} {`,
        `    type route`,
        `    slave { pcm "${prefix}_dmix"; channels ${maxCh} }`,
        `    ttable {`,
        `        0.${ch} 1.0`,
        `        1.${ch2} 1.0`,
        `    }`,
        `}`,
        '',
      );

      virtualDevices.push({
        id: devId,
        mode: 'stereo',
        cardId: card.cardId,
        outputChannels: [ch, ch2],
        label: `Card ${card.cardId} → Ch ${ch}+${ch2} (${labelA}/${labelB})`,
      });
    }
  }

  // Default device
  const defaultDev =
    virtualDevices.find((v) => v.mode === 'stereo')?.id ??
    virtualDevices[0]?.id ??
    'hw:0,0';
  lines.push(
    `pcm.!default {`,
    `    type plug`,
    `    slave.pcm "${defaultDev}"`,
    `}`,
    '',
    `ctl.!default {`,
    `    type hw`,
    `    card 0`,
    `}`,
    '',
  );

  // Include local overrides if present
  lines.push(
    `# To add local customisations, create /etc/asound.local.conf`,
    '',
  );

  return { content: lines.join('\n'), virtualDevices };
}
