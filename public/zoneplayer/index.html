<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lox-audioserver Web Zone Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      color-scheme: dark;
      --bg: #161b25;
      --panel: rgba(255, 255, 255, 0.04);
      --border: rgba(255, 255, 255, 0.08);
      --fg: #f0f3f8;
      --muted: #aab3c2;
      --accent: #1ed760;
      --accent-glow: rgba(30, 215, 96, 0.35);
      --danger: #f29f9f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter Tight", "SF Pro Display", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      background:
        radial-gradient(120% 120% at 20% 20%, rgba(30, 215, 96, 0.12), transparent 50%),
        radial-gradient(110% 130% at 80% 8%, rgba(120, 170, 255, 0.12), transparent 45%),
        linear-gradient(160deg, #0f131d 0%, #161b25 70%, #0f141d 100%);
      color: var(--fg);
      display: grid;
      place-items: center;
      padding: 28px;
    }
    main {
      width: min(1200px, 96vw);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 30px;
      padding: 32px;
      box-shadow:
        0 40px 140px rgba(0, 0, 0, 0.55),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(12px);
    }
    h1 {
      margin: 0 0 10px;
      font-size: 24px;
      letter-spacing: 0.02em;
      color: var(--accent);
    }
    p.subhead {
      margin: 0 0 22px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }
    .grid {
      display: grid;
      gap: 18px;
    }
    .fields {
      display: none;
    }
    label {
      display: grid;
      gap: 4px;
      color: var(--muted);
      font-size: 13px;
      letter-spacing: 0.01em;
    }
    input, button, select {
      font: inherit;
    }
    input[type="text"], input[type="url"], select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--fg);
      padding: 9px 11px;
      outline: none;
      transition: border-color 120ms ease, background-color 120ms ease;
    }
    input:focus, select:focus {
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.06);
    }
    select {
      appearance: none;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
      padding-right: 30px;
      position: relative;
      border-color: rgba(255, 255, 255, 0.12);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    }
    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      border: 1px solid var(--border);
      background: linear-gradient(135deg, rgba(30, 215, 96, 0.2), rgba(30, 215, 96, 0.1));
      color: var(--fg);
      padding: 11px 16px;
      border-radius: 14px;
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); border-color: var(--accent); box-shadow: 0 10px 32px rgba(30, 215, 96, 0.25); }
    button:active { transform: translateY(0); }
    button.secondary {
      background: rgba(255, 255, 255, 0.05);
    }
    .status {
      margin: 0;
      font-size: 15px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 14px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--border);
      width: fit-content;
    }
    .status::before {
      content: '';
      display: inline-block;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: var(--muted);
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.03);
    }
    .status.ok { color: var(--accent); border-color: var(--accent-glow); }
    .status.ok::before { background: var(--accent); box-shadow: 0 0 0 4px rgba(30, 215, 96, 0.12); }
    .status.error { color: var(--danger); border-color: rgba(242, 159, 159, 0.35); }
    .status.error::before { background: var(--danger); }
    .debug {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      line-height: 1.45;
      color: var(--muted);
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: start;
      min-height: 120px;
      position: relative;
      overflow: hidden;
    }
    .debug::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(30, 215, 96, 0.05), transparent 35%);
      pointer-events: none;
    }
    .hint {
      color: var(--muted);
      font-size: 12px;
    }
    .split {
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(160px, 220px) 1fr auto;
      align-items: center;
    }
    .slider {
      display: flex;
      gap: 10px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }
    input[type="range"] {
      width: 100%;
    }
    .card {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border-radius: 20px;
      padding: 18px;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.03),
        0 10px 28px rgba(0, 0, 0, 0.25);
    }
    .status-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 18px;
    }
    .nowplaying {
      display: grid;
      grid-template-columns: 190px 1fr;
      gap: 18px;
      align-items: center;
      font-size: 14px;
      color: var(--muted);
      position: relative;
      overflow: hidden;
      background: linear-gradient(120deg, rgba(30, 215, 96, 0.12), rgba(255, 255, 255, 0.04));
      padding: 16px;
    }
    .nowplaying::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(60% 60% at 20% 20%, rgba(255, 255, 255, 0.08), transparent 60%);
      opacity: 0.5;
    }
    .nowplaying .np-meta {
      display: grid;
      gap: 8px;
    }
    .np-title {
      color: var(--fg);
      font-weight: 760;
      font-size: 22px;
      letter-spacing: -0.01em;
    }
    .np-artist {
      color: var(--muted);
      font-size: 15px;
    }
    .np-album {
      color: var(--muted);
      font-size: 14px;
    }
    .np-timing {
      display: grid;
      gap: 6px;
      margin-top: 10px;
    }
    .np-time-label {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.02em;
    }
    .np-progress {
      position: relative;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }
    .np-progress-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), rgba(30, 215, 96, 0.6));
      border-radius: 999px;
      box-shadow: 0 0 8px rgba(30, 215, 96, 0.35);
      transition: width 150ms ease;
    }
    .player-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 8px;
    }
    .player-controls button {
      border-radius: 50%;
      padding: 10px;
      min-width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      color: var(--fg);
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .player-controls button:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 6px 16px rgba(30, 215, 96, 0.2);
    }
    .player-controls button:active {
      transform: translateY(0);
    }
    .player-controls .icon {
      font-size: 16px;
      line-height: 1;
    }
    .player-controls .volume-label {
      margin-left: 8px;
      color: var(--muted);
      font-size: 12px;
    }
    .cover {
      width: 190px;
      height: 190px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
    }
    .cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    @media (max-width: 860px) {
      body {
        padding: 16px;
      }
      body.idle-fullscreen {
        padding: 0;
      }
      main {
        width: 100%;
        padding: 22px;
        border-radius: 22px;
      }
      body.idle-fullscreen main {
        width: 100vw;
        height: 100vh;
        border-radius: 0;
        padding: 0;
        background: none;
        box-shadow: none;
      }
      h1 {
        font-size: 21px;
      }
      .subhead {
        display: none;
      }
      body.idle-fullscreen h1 {
        display: none;
      }
      .split {
        grid-template-columns: 1fr;
        gap: 10px;
        align-items: stretch;
      }
      .actions {
        justify-content: flex-start;
        width: 100%;
      }
      .card {
        padding: 14px;
      }
      .status-card {
        display: none;
      }
      body.idle-fullscreen .split,
      body.idle-fullscreen .status-card {
        display: none;
      }
      .nowplaying {
        grid-template-columns: 1fr;
        text-align: center;
        justify-items: center;
        padding: 18px;
        gap: 14px;
      }
      body.idle-fullscreen .nowplaying {
        height: 100vh;
        align-content: center;
        gap: 18px;
        border: none;
        box-shadow: none;
        background: linear-gradient(145deg, rgba(0,0,0,0.65), rgba(0,0,0,0.3)), linear-gradient(120deg, rgba(30, 215, 96, 0.18), rgba(255, 255, 255, 0.08));
        border-radius: 0;
        padding: 28px;
      }
      .cover {
        width: 220px;
        height: 220px;
      }
      body.idle-fullscreen .cover {
        width: 70vw;
        height: 70vw;
        max-width: 360px;
        max-height: 360px;
      }
      .np-meta {
        width: 100%;
      }
      .player-controls {
        flex-wrap: wrap;
        justify-content: center;
      }
    .player-controls input[type="range"] {
      flex: 1 1 100%;
      margin-top: 8px;
    }
    .debug {
      display: none;
    }
      .split {
        grid-template-columns: 1fr auto;
        align-items: center;
      }
      .split label {
        max-width: 70%;
      }
      .actions {
        width: auto;
      }
      #zoneSelect {
        min-width: 0;
        width: 100%;
      }
      #toggleBtn {
        white-space: nowrap;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>Lox AudioServer Zone Player</h1>
    <p class="subhead">Listen as a Snapcast or Sendspin client via the built-in WebSocket streams. Pick a protocol, set server/stream, then connect.</p>

    <div class="grid">
      <div class="split">
        <label style="margin:0;">Zone
          <select id="zoneSelect">
            <option value="">Loading zones…</option>
          </select>
        </label>
        <div class="actions" style="margin-left:auto;">
          <button id="toggleBtn" type="button">Connect</button>
        </div>
      </div>

      <div class="card status-card">
        <div id="status" class="status">Idle</div>
      </div>

      <div class="card nowplaying">
        <div class="cover"><img id="npCover" alt="Cover art"></div>
        <div class="np-meta">
          <div class="np-title" id="npTitle">Title</div>
          <div class="np-artist" id="npArtist">Artist</div>
          <div class="np-album" id="npAlbum">Album</div>
          <div class="np-timing">
            <div class="np-time-label" id="npTimeLabel">00:00 / 00:00</div>
            <div class="np-progress"><div class="np-progress-fill" id="npProgressFill"></div></div>
          </div>
          <div class="player-controls">
            <button type="button" aria-label="Previous" data-action="prev"><span class="icon">⏮</span></button>
            <button type="button" aria-label="Play/Pause" data-action="playpause"><span class="icon">⏯</span></button>
            <button type="button" aria-label="Next" data-action="next"><span class="icon">⏭</span></button>
            <span class="volume-label">Volume</span>
            <input id="inlineVolume" type="range" min="0" max="100" value="100" style="flex:1; accent-color: var(--accent);" />
          </div>
        </div>
      </div>

      <div class="card debug" id="debug"></div>
    </div>
  </main>

  <script>
    (() => {
      const BASE_HEADER_SIZE = 26;
      const textDecoder = new TextDecoder();
      const textEncoder = new TextEncoder();

      const searchParams = new URLSearchParams(location.search);
      const statusEl = document.getElementById('status');
      const debugEl = document.getElementById('debug');
      const npTitle = document.getElementById('npTitle');
      const npArtist = document.getElementById('npArtist');
      const npAlbum = document.getElementById('npAlbum');
      const npCover = document.getElementById('npCover');
      const npTimeLabel = document.getElementById('npTimeLabel');
      const npProgressFill = document.getElementById('npProgressFill');
      const defaultCover =
        'data:image/svg+xml;utf8,' +
        encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" role="img" aria-labelledby="title desc"><title>Default Cover</title><desc>Abstract default cover art for Lox AudioServer</desc><defs><linearGradient id="g" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#1ed760" stop-opacity="0.85"/><stop offset="60%" stop-color="#111720" stop-opacity="0.95"/><stop offset="100%" stop-color="#0b0f17" stop-opacity="1"/></linearGradient></defs><rect width="512" height="512" fill="#0d1119"/><rect x="12" y="12" width="488" height="488" rx="32" fill="url(#g)"/><circle cx="180" cy="332" r="62" fill="none" stroke="#d7e2f2" stroke-width="10" opacity="0.8"/><circle cx="332" cy="260" r="52" fill="none" stroke="#d7e2f2" stroke-width="10" opacity="0.65"/><path d="M270 150v180c0 28-22 50-50 50s-50-22-50-50 22-50 50-50c13 0 25 5 34 13V150h16z" fill="#d7e2f2" opacity="0.9"/><path d="M290 138v150c0 23 19 42 42 42s42-19 42-42-19-42-42-42c-11 0-22 4-30 11V138h-12z" fill="#c5d4e6" opacity="0.75"/><circle cx="260" cy="260" r="238" fill="none" stroke="#ffffff" stroke-opacity="0.05" stroke-width="18"/><circle cx="260" cy="260" r="208" fill="none" stroke="#ffffff" stroke-opacity="0.04" stroke-width="12"/></svg>`);
      const zoneSelect = document.getElementById('zoneSelect');
      const toggleBtn = document.getElementById('toggleBtn');
      const inlineVolume = document.getElementById('inlineVolume');
      const presetZoneId = searchParams.get('zone') || searchParams.get('zone_id') || '';
      const autoConnectRequested =
        presetZoneId ||
        ['1', 'true', 'yes', 'on'].includes((searchParams.get('autoconnect') || '').toLowerCase()) ||
        ['1', 'true', 'yes', 'on'].includes((searchParams.get('connect') || '').toLowerCase());
      let lastStatusText = '';
      npCover.src = defaultCover;
      npCover.style.visibility = 'visible';

      let currentProtocol = 'snapcast';
      const snapClientId = genClientId();
      const timingState = { pos: 0, duration: 0, updatedAt: performance.now() };

      let ws = null;
      let inbound = new Uint8Array(0);
      let audioCtx = null;
      let gainNode = null;
      let currentFormat = null;
      let baseTimestampUs = null;
      let baseAudioTime = 0;
      let scheduledUntil = 0;
      let status = 'Idle';
      let playbackDelaySec = 0.35;
      const MAX_AHEAD_SEC = 6;
      let timeInterval = null;
      let nextId = Math.floor(Math.random() * 5000) + 1;
      let metaSocket = null;
      let shouldReconnect = false;
      let reconnectTimer = null;
      let reconnectAttempts = 0;
      let lastReconnectAt = 0;
      let sendspinPlayer = null;
      let sendspinModule = null;
      let zones = [];
      let isConnected = false;
      let isPlaying = false;
      let autoConnectDone = false;
      let autoConnectAttempts = 0;
      const MAX_AUTO_CONNECT_ATTEMPTS = 3;
      let lastConnectOpenedAt = 0;
      let fastCloseCount = 0;
      const MAX_FAST_CLOSES = 3;
      const IDLE_FULLSCREEN_DELAY = 15000;
      let idleFullscreenTimer = null;
      const requestAutoConnect = () => {
        if (!autoConnectRequested || autoConnectDone || autoConnectAttempts >= MAX_AUTO_CONNECT_ATTEMPTS) return;
        autoConnectAttempts += 1;
        window.setTimeout(() => connect(), 150);
      };

      const getSelectedZone = () => zones.find((z) => String(z.id) === zoneSelect.value.trim());
      const resolveClientId = (proto = currentProtocol) => {
        if (proto === 'sendspin') {
          const z = getSelectedZone();
          const base = (z?.name || `zone-${z?.id || 'client'}`)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '') || 'client';
          return `sendspin-${base}`;
        }
        return snapClientId;
      };

      const nowUs = () => Math.trunc(performance.now() * 1000);
      const formatTime = (seconds) => {
        if (!Number.isFinite(seconds) || seconds < 0) return '00:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      };
      const setTiming = (posSec = 0, durSec = 0) => {
        timingState.pos = Math.max(0, posSec || 0);
        timingState.duration = Math.max(0, durSec || 0);
        timingState.updatedAt = performance.now();
        const pct =
          timingState.duration > 0
            ? Math.min(100, (timingState.pos / timingState.duration) * 100)
            : 0;
        npTimeLabel.textContent = `${formatTime(timingState.pos)} / ${formatTime(timingState.duration)}`;
        npProgressFill.style.width = `${pct}%`;
      };

      const logDebug = () => {
        const ahead = audioCtx ? Math.max(0, scheduledUntil - audioCtx.currentTime) : 0;
        const fields = [
          ['Status', status],
          ['Zone', zoneSelect.value || 'default'],
          ['Protocol', currentProtocol],
          ['Client', resolveClientId(currentProtocol)],
          [
            'Format',
            currentFormat
              ? `PCM ${currentFormat.sampleRate}Hz ${currentFormat.channels}ch ${currentFormat.bitDepth}-bit`
              : 'waiting',
          ],
          ['Buffer', `${playbackDelaySec.toFixed(2)}s lead`],
          ['Ahead', `${ahead.toFixed(2)}s scheduled`],
          ['Volume', `${inlineVolume.value}%`],
        ];
        debugEl.innerHTML = fields
          .map(
            ([k, v]) =>
              `<div><span style="color:var(--muted)">${k}</span><br><strong style="color:var(--fg);font-weight:600">${v}</strong></div>`,
          )
          .join('');
      };

      const resetIdleFullscreen = () => {
        if (idleFullscreenTimer) {
          clearTimeout(idleFullscreenTimer);
          idleFullscreenTimer = null;
        }
        document.body.classList.remove('idle-fullscreen');
      };

      const scheduleIdleFullscreen = (allow) => {
        if (!allow) {
          resetIdleFullscreen();
          return;
        }
        if (!window.matchMedia('(max-width: 860px)').matches) return;
        resetIdleFullscreen();
        idleFullscreenTimer = window.setTimeout(() => {
          document.body.classList.add('idle-fullscreen');
        }, IDLE_FULLSCREEN_DELAY);
      };

      const setStatus = (text, ok = false, error = false) => {
        if (lastStatusText === text && status === (ok ? 'ok' : error ? 'error' : '')) return;
        status = text;
        statusEl.textContent = text;
        statusEl.classList.toggle('ok', ok);
        statusEl.classList.toggle('error', error);
        lastStatusText = text;
        logDebug();
        toggleBtn.textContent = isConnected ? 'Disconnect' : 'Connect';
        const lower = text.toLowerCase();
        if (/playing/.test(lower)) {
          isPlaying = true;
        }
        if (/stopped|idle|disconnected|error/.test(lower)) {
          isPlaying = false;
        }
        const shouldFullscreen = isConnected && isPlaying;
        if (shouldFullscreen) {
          scheduleIdleFullscreen(true);
        } else {
          resetIdleFullscreen();
        }
      };

      const applyMetadata = (meta) => {
        if (!meta) return;
        npTitle.textContent = meta.title || 'Title';
        npArtist.textContent = Array.isArray(meta.artist) ? meta.artist.join(', ') : meta.artist || 'Artist';
        npAlbum.textContent = meta.album || '';
        npCover.src = meta.artUrl || defaultCover;
        npCover.style.visibility = 'visible';
        if (meta.title) {
          document.title = `${meta.title} · Lox AudioServer`;
        }
        if (meta.progress) {
          const pos = typeof meta.progress.position === 'number' ? meta.progress.position : timingState.pos;
          const dur = typeof meta.progress.duration === 'number' ? meta.progress.duration : timingState.duration;
          setTiming(pos, dur);
        }
      };

      const ensureAudio = async () => {
        if (!audioCtx) {
          audioCtx = new AudioContext();
          gainNode = audioCtx.createGain();
          const initialVol = inlineVolume?.valueAsNumber ?? 100;
          gainNode.gain.value = initialVol / 100;
          gainNode.connect(audioCtx.destination);
        }
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
      };

      const loadSendspin = async () => {
        if (sendspinModule) return sendspinModule;
        sendspinModule = await import('https://unpkg.com/@music-assistant/sendspin-js@0.4.5/dist/index.js');
        return sendspinModule;
      };

      const patchSendspinPlayer = (p) => {
        if (!p || p._loxPatched) return;
        const protocol = p?.protocolHandler;
        if (!protocol) return;
        const originalHello = protocol.sendClientHello.bind(protocol);
        protocol.sendClientHello = () => {
          try {
            const clientId = protocol.playerId || resolveClientId('sendspin');
            const name = protocol.playerName || 'Sendspin Web';
            const supportedFormats = protocol.getSupportedFormats ? protocol.getSupportedFormats() : [];
            const hello = {
              type: 'client/hello',
              payload: {
                client_id: clientId,
                name,
                version: 1,
                supported_roles: ['player@v1', 'metadata@v1', 'artwork@v1'],
                device_info: {
                  product_name: (typeof navigator !== 'undefined' && navigator.userAgent) || 'Browser',
                  manufacturer: (typeof navigator !== 'undefined' && navigator.vendor) || 'Unknown',
                  software_version: (typeof navigator !== 'undefined' && navigator.appVersion) || 'N/A',
                },
                player_support: {
                  supported_formats: supportedFormats,
                  buffer_capacity: protocol.bufferCapacity,
                  supported_commands: ['volume', 'mute'],
                },
                'artwork@v1_support': {
                  channels: [
                    {
                      source: 'album',
                      format: 'jpeg',
                      media_width: 800,
                      media_height: 800,
                    },
                  ],
                },
              },
            };
            protocol.wsManager.send(hello);
          } catch (err) {
            console.warn('[Sendspin] custom hello failed, using default', err);
            originalHello();
          }
        };

        const originalHandle = protocol.handleServerMessage.bind(protocol);
        protocol.handleServerMessage = (message) => {
          try {
            const meta = message?.payload?.metadata;
            if (meta) {
              applyMetadata(meta);
            }
          } catch (err) {
            console.warn('[Sendspin] metadata apply failed', err);
          }
          return originalHandle(message);
        };

        p._loxPatched = true;
      };

      const ensurePathForProtocol = (url, proto) => {
        try {
          const u = new URL(url);
          const path = (u.pathname || '').toLowerCase();
          if (proto === 'sendspin') {
            if (path === '/' || path === '/snapcast' || path === '/snapcast/') {
              u.pathname = '/sendspin';
            }
          } else {
            if (path === '/' || path === '/sendspin' || path === '/sendspin/') {
              u.pathname = '/snapcast';
            }
          }
          return u.toString();
        } catch {
          return url;
        }
      };

      const computeWsBase = (proto = currentProtocol) => {
        const base = normalizeWsUrl(location.origin.replace(/^http/i, 'ws'));
        return ensurePathForProtocol(base, proto === 'sendspin' ? 'sendspin' : 'snapcast');
      };

      const normalizeStreamUrl = () => {
        const base = computeWsBase('snapcast');
        if (!base) return null;
        const stream = zoneSelect.value.trim();
        if (!stream) return base;
        const joiner = base.includes('?') ? '&' : '?';
        return `${base}${joiner}stream=${encodeURIComponent(stream)}`;
      };

      const buildRpcUrl = () => {
        const base = computeWsBase('snapcast');
        if (!base) return null;
        try {
          const u = new URL(base);
          u.pathname = u.pathname.replace(/\/snapcast.*/, '/snapcast/jsonrpc');
          if (!/\/snapcast\//.test(u.pathname)) {
            u.pathname = '/snapcast/jsonrpc';
          }
          u.search = '';
          return u.toString();
        } catch {
          return null;
        }
      };

      const connect = async () => {
        if (currentProtocol === 'sendspin') {
          shouldReconnect = false;
          await connectSendspin();
          return;
        }
        shouldReconnect = true;
        const url = normalizeStreamUrl();
        if (!url) {
        setStatus('Error: invalid server URL', false, true);
          return;
        }
        await ensureAudio();
        shouldReconnect = true;
        disconnect(true, true);
        connectMetadata();
        inbound = new Uint8Array(0);
        currentFormat = null;
        baseTimestampUs = null;
        baseAudioTime = 0;
        scheduledUntil = audioCtx ? audioCtx.currentTime : 0;
        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';
        setStatus(`Connecting to ${url}…`);
        ws.onopen = () => {
          lastConnectOpenedAt = performance.now();
          isConnected = true;
          autoConnectDone = true;
          isPlaying = false;
          isPlaying = false;
          reconnectAttempts = 0;
          setStatus('Connected', true, false);
          sendHello();
          sendTimePing();
          timeInterval = window.setInterval(() => sendTimePing(), 3000);
        };
        ws.onmessage = (event) => {
          if (!(event.data instanceof ArrayBuffer)) return;
          handleData(new Uint8Array(event.data));
        };
        ws.onclose = (event) => {
          const aliveMs = lastConnectOpenedAt ? performance.now() - lastConnectOpenedAt : 0;
          if (aliveMs > 0 && aliveMs < 2000) {
            fastCloseCount += 1;
          } else {
            fastCloseCount = 0;
          }
          isConnected = false;
          isPlaying = false;
          if (fastCloseCount >= MAX_FAST_CLOSES) {
            shouldReconnect = false;
            setStatus('Disconnected · too many quick closes', false, true);
            return;
          }
          const willRetry = shouldReconnect;
          setStatus(
            willRetry
              ? `Disconnected (code ${event.code || 0}) · reconnecting…`
              : `Disconnected (code ${event.code || 0})`,
            false,
            !willRetry,
          );
          if (timeInterval) {
            clearInterval(timeInterval);
            timeInterval = null;
          }
          if (autoConnectRequested && !autoConnectDone) {
            requestAutoConnect();
          }
          if (willRetry) {
            if (reconnectTimer) window.clearTimeout(reconnectTimer);
            reconnectAttempts += 1;
            const now = Date.now();
            const backoff = Math.min(5000, 600 + reconnectAttempts * 400);
            if (reconnectAttempts >= 5 && now - lastReconnectAt < 10000) {
              shouldReconnect = false;
              setStatus('Disconnected · retries paused', false, true);
              return;
            }
            lastReconnectAt = now;
            reconnectTimer = window.setTimeout(() => {
              reconnectTimer = null;
              connect().catch(() => setStatus('Reconnect failed', false, true));
            }, backoff);
          }
        };
        ws.onerror = () => {
          isConnected = false;
          isPlaying = false;
          setStatus('WebSocket error', false, true);
        };
      };

      const disconnect = (silent = false, keepReconnect = false) => {
        shouldReconnect = keepReconnect ? shouldReconnect : false;
        if (reconnectTimer) {
          window.clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        reconnectAttempts = 0;
        if (ws) {
          ws.close();
          ws = null;
        }
        isConnected = false;
        if (!silent) {
          setStatus('Disconnected');
        }
        if (timeInterval) {
          clearInterval(timeInterval);
          timeInterval = null;
        }
        inbound = new Uint8Array(0);
        baseTimestampUs = null;
        baseAudioTime = 0;
        if (metaSocket) {
          try { metaSocket.close(); } catch {}
          metaSocket = null;
        }
        if (sendspinPlayer) {
          try { sendspinPlayer.disconnect?.(); } catch {}
          try { sendspinPlayer.destroy?.(); } catch {}
          sendspinPlayer = null;
        }
      };

      function genClientId() {
        return `snap-web-${Math.random().toString(16).slice(2, 7)}`;
      }

      const sendHello = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const stored = localStorage.getItem('snapcast_client_id') || '';
        const id = stored || resolveClientId('snapcast');
        localStorage.setItem('snapcast_client_id', id);
        const payload = JSON.stringify({ ID: id });
        const body = new Uint8Array(4 + textEncoder.encode(payload).length);
        const view = new DataView(body.buffer);
        const jsonBytes = textEncoder.encode(payload);
        view.setUint32(0, jsonBytes.length, true);
        body.set(jsonBytes, 4);
        sendMessage(5, 0, body);
      };

      const sendTimePing = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        sendMessage(4, 0, new Uint8Array(0));
      };

      const sendMessage = (type, refersTo, payload) => {
        const id = nextMessageId();
        const header = new ArrayBuffer(BASE_HEADER_SIZE);
        const view = new DataView(header);
        const now = nowUs();
        const sec = Math.floor(now / 1_000_000);
        const usec = Math.floor(now - sec * 1_000_000);
        view.setUint16(0, type & 0xffff, true);
        view.setUint16(2, id & 0xffff, true);
        view.setUint16(4, refersTo & 0xffff, true);
        view.setInt32(6, sec, true);
        view.setInt32(10, usec, true);
        view.setInt32(14, sec, true);
        view.setInt32(18, usec, true);
        view.setUint32(22, payload.byteLength, true);
        ws?.send(new Blob([header, payload]));
        return id;
      };

      const nextMessageId = () => {
        nextId = (nextId % 0xffff) + 1;
        return nextId;
      };

      const handleData = (data) => {
        inbound = concatBuffers(inbound, data);
        while (inbound.length >= BASE_HEADER_SIZE) {
          const header = parseHeader(inbound);
          if (!header) break;
          const total = BASE_HEADER_SIZE + header.size;
          if (inbound.length < total) break;
          const body = inbound.slice(BASE_HEADER_SIZE, total);
          inbound = inbound.slice(total);
          handleMessage(header, body);
        }
      };

      const parseHeader = (buffer) => {
        try {
          const view = new DataView(buffer.buffer, buffer.byteOffset, BASE_HEADER_SIZE);
          return {
            type: view.getUint16(0, true),
            id: view.getUint16(2, true),
            refersTo: view.getUint16(4, true),
            sent: {
              sec: view.getInt32(6, true),
              usec: view.getInt32(10, true),
            },
            size: view.getUint32(22, true),
          };
        } catch {
          return null;
        }
      };

      const handleMessage = (header, body) => {
        switch (header.type) {
          case 1:
            handleCodecHeader(body);
            break;
          case 2:
            handleAudioChunk(body);
            break;
          case 3:
            handleSettings(body);
            break;
          default:
            break;
        }
      };

      const handleSettings = (body) => {
        if (body.byteLength < 4) return;
        const len = new DataView(body.buffer, body.byteOffset, 4).getUint32(0, true);
        const jsonBytes = body.slice(4, 4 + len);
        try {
          const parsed = JSON.parse(textDecoder.decode(jsonBytes));
          if (typeof parsed.bufferMs === 'number') {
            playbackDelaySec = Math.max(0.1, parsed.bufferMs / 1000);
          }
          logDebug();
        } catch {
          // ignore malformed settings
        }
      };

      const handleCodecHeader = (body) => {
        if (body.byteLength < 4) return;
        const view = new DataView(body.buffer, body.byteOffset, body.byteLength);
        const codecLen = view.getUint32(0, true);
        const codecName = textDecoder.decode(body.slice(4, 4 + codecLen));
        const wavLen = view.getUint32(4 + codecLen, true);
        const wavOffset = 8 + codecLen;
        if (wavOffset + wavLen > body.byteLength) return;
        if (codecName.trim().toLowerCase() !== 'pcm') return;
        const wav = new DataView(body.buffer, body.byteOffset + wavOffset, wavLen);
        const channels = wav.getUint16(22, true);
        const sampleRate = wav.getUint32(24, true);
        const bitDepth = wav.getUint16(34, true);
        currentFormat = { channels, sampleRate, bitDepth };
        baseTimestampUs = null;
        isPlaying = true;
        baseAudioTime = audioCtx ? audioCtx.currentTime + playbackDelaySec : 0;
        setStatus(`Ready (${channels}ch ${sampleRate}Hz)`, true, false);
      };

      const handleAudioChunk = (body) => {
        if (!currentFormat || body.byteLength < 12 || !audioCtx || !gainNode) return;
        const view = new DataView(body.buffer, body.byteOffset, body.byteLength);
        const sec = view.getInt32(0, true);
        const usec = view.getInt32(4, true);
        const size = view.getUint32(8, true);
        if (12 + size > body.byteLength) return;
        const pcm = body.slice(12, 12 + size);
        const timestampUs = sec * 1_000_000 + usec;
        schedulePcm(timestampUs, pcm);
      };

      const schedulePcm = (timestampUs, pcm) => {
        const bytesPerFrame = (currentFormat.bitDepth / 8) * currentFormat.channels;
        if (bytesPerFrame <= 0) return;
        const frames = Math.floor(pcm.byteLength / bytesPerFrame);
        if (frames <= 0) return;
        const duration = frames / currentFormat.sampleRate;

        if (!baseTimestampUs) {
          baseTimestampUs = timestampUs;
          baseAudioTime = Math.max(audioCtx.currentTime + playbackDelaySec, audioCtx.currentTime + 0.05);
          scheduledUntil = baseAudioTime;
        }

        const relativeSec = (timestampUs - baseTimestampUs) / 1_000_000;
        let startAt = baseAudioTime + relativeSec;
        const minStart = audioCtx.currentTime + 0.03;
        const maxStart = audioCtx.currentTime + MAX_AHEAD_SEC;
        if (startAt < minStart) {
          // slide the base forward to avoid piling up stale chunks
          const delta = minStart - startAt;
          baseAudioTime += delta;
          startAt = minStart;
        } else if (startAt > maxStart) {
          // If we’re way ahead (e.g., after reconnect), reset anchor to keep buffer sane.
          baseTimestampUs = timestampUs;
          baseAudioTime = audioCtx.currentTime + playbackDelaySec;
          startAt = baseAudioTime;
          scheduledUntil = startAt;
        }
        const buffer = audioCtx.createBuffer(currentFormat.channels, frames, audioCtx.sampleRate);
        writePcmToBuffer(buffer, pcm, currentFormat);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = currentFormat.sampleRate / audioCtx.sampleRate;
        source.connect(gainNode);
        try {
          source.start(startAt);
          scheduledUntil = Math.max(scheduledUntil, startAt + duration * source.playbackRate.value);
        } catch {
          // ignore
        }
        logDebug();
      };

      const writePcmToBuffer = (buffer, pcm, format) => {
        const bytesPerFrame = (format.bitDepth / 8) * format.channels;
        const frames = Math.min(buffer.length, Math.floor(pcm.byteLength / bytesPerFrame));
        let offset = 0;
        for (let frame = 0; frame < frames; frame++) {
          for (let ch = 0; ch < format.channels; ch++) {
            const value = readSample(pcm, offset, format.bitDepth);
            buffer.getChannelData(ch)[frame] = value;
            offset += format.bitDepth / 8;
          }
        }
      };

      const readSample = (pcm, offset, bitDepth) => {
        const view = new DataView(pcm.buffer, pcm.byteOffset + offset, pcm.byteLength - offset);
        switch (bitDepth) {
          case 16:
            return Math.max(-1, Math.min(1, view.getInt16(0, true) / 32768));
          case 24: {
            const b0 = pcm[offset];
            const b1 = pcm[offset + 1];
            const b2 = pcm[offset + 2];
            const sample = (b2 << 16) | (b1 << 8) | b0;
            const signed = sample & 0x800000 ? sample | ~0xffffff : sample;
            return Math.max(-1, Math.min(1, signed / 0x7fffff));
          }
          case 32:
            return Math.max(-1, Math.min(1, view.getInt32(0, true) / 2147483648));
          default:
            return 0;
        }
      };

      const concatBuffers = (a, b) => {
        const out = new Uint8Array(a.length + b.length);
        out.set(a, 0);
        out.set(b, a.length);
        return out;
      };

      function normalizeWsUrl(raw) {
        if (!raw) return null;
        let s = String(raw).trim();
        if (!s) return null;
        if (s.startsWith('//')) s = `ws:${s}`;
        if (/^https?:\/\//i.test(s)) {
          s = s.replace(/^http:/i, 'ws:').replace(/^https:/i, 'wss:');
        } else if (!/^wss?:\/\//i.test(s)) {
          s = `ws://${s}`;
        }
        try {
          return new URL(s, location.href).toString();
        } catch {
          return null;
        }
      }

      toggleBtn.addEventListener('click', (event) => {
        event.preventDefault();
        if (isConnected) {
          disconnect();
        } else {
          connect();
        }
        resetIdleFullscreen();
      });
      inlineVolume.addEventListener('input', () => {
        const value = inlineVolume.valueAsNumber;
        if (gainNode) {
          gainNode.gain.value = value / 100;
        }
        if (sendspinPlayer && typeof sendspinPlayer.setVolume === 'function') {
          sendspinPlayer.setVolume(value / 100);
        }
        logDebug();
        resetIdleFullscreen();
      });

      let rpcRequestId = 1;

      const sendSnapcastRpc = (payload) => {
        const rpcUrl = buildRpcUrl();
        if (!rpcUrl) return;
        const sendPayload = (socket) => {
          try {
            socket.send(JSON.stringify(payload));
          } catch {
            /* ignore */
          }
        };
        if (metaSocket && metaSocket.readyState === WebSocket.OPEN) {
          sendPayload(metaSocket);
          return;
        }
        const temp = new WebSocket(rpcUrl);
        temp.onopen = () => {
          sendPayload(temp);
          setTimeout(() => {
            try { temp.close(); } catch {}
          }, 200);
        };
      };

      const sendControl = (action) => {
        if (currentProtocol !== 'snapcast') return;
        const streamId = zoneSelect.value.trim();
        if (!streamId) return;
        let command = action;
        if (action === 'prev') command = 'previous';
        if (action === 'playpause') command = 'playPause';
        const payload = {
          id: rpcRequestId++,
          jsonrpc: '2.0',
          method: 'Stream.Control',
          params: {
            id: streamId,
            command,
            params: {},
          },
        };
        sendSnapcastRpc(payload);
      };

      document.querySelectorAll('.player-controls button[data-action]').forEach((btn) => {
        btn.addEventListener('click', () => {
          const action = btn.getAttribute('data-action');
          console.info('[Player controls] action clicked', action);
          if (action) {
            sendControl(action);
          }
          setStatus(`${status} · ${action} pressed`, status === 'Connected' || status.startsWith('Ready'), false);
          resetIdleFullscreen();
        });
      });
      // No protocol dropdown; protocol is derived from the selected zone transports.

      const pickStream = (streams) => {
        if (!Array.isArray(streams)) return null;
        const target = zoneSelect.value.trim() || null;
        if (target) {
          return streams.find((s) => s.id === target) || null;
        }
        return streams[0] || null;
      };

      const connectMetadata = () => {
        if (currentProtocol === 'sendspin') return;
        const rpcUrl = buildRpcUrl();
        if (!rpcUrl) return;
        if (metaSocket) {
          try { metaSocket.close(); } catch {}
          metaSocket = null;
        }
        metaSocket = new WebSocket(rpcUrl);
        metaSocket.onopen = () => {
          metaSocket?.send(
            JSON.stringify({ id: 1, jsonrpc: '2.0', method: 'Server.GetStatus' }),
          );
        };
        metaSocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.result?.streams) {
        const stream = pickStream(data.result.streams);
        if (stream?.properties?.metadata) {
          applyMetadata(stream.properties.metadata);
        }
        if (typeof stream?.properties?.position === 'number') {
                const dur = stream?.properties?.metadata?.duration ?? 0;
                setTiming(stream.properties.position, dur);
              }
            } else if (data.method === 'Server.OnUpdate') {
        const stream = pickStream(data.params?.server?.streams);
        if (stream?.properties?.metadata) {
          applyMetadata(stream.properties.metadata);
        }
        if (typeof stream?.properties?.position === 'number') {
                const dur = stream?.properties?.metadata?.duration ?? 0;
                setTiming(stream.properties.position, dur);
              }
            }
          } catch {
            // ignore
          }
        };
        metaSocket.onclose = () => {
          metaSocket = null;
        };
      };

      const connectSendspin = async () => {
        const baseNorm = computeWsBase('sendspin');
        const base = baseNorm ? ensurePathForProtocol(baseNorm, 'sendspin') : null;
        if (!base) {
          setStatus('Error: invalid server URL', false, true);
          return;
        }
        disconnect(true, true);
        setStatus(`Connecting to ${base}…`);
        try {
          const { SendspinPlayer } = await loadSendspin();
          const playerId = resolveClientId('sendspin');
          sendspinPlayer = new SendspinPlayer({
          playerId,
          baseUrl: base,
          bufferCapacity: 2 * 1024 * 1024,
          useHardwareVolume: false,
          onStateChange: (state) => {
            if (state?.isConnected) {
              isConnected = true;
              autoConnectDone = true;
            }
            isPlaying = !!state?.isPlaying;
            setStatus(state.isPlaying ? 'Playing' : 'Stopped', state.isPlaying, false);
            const meta = state.metadata || state?.payload?.metadata;
            if (meta) applyMetadata(meta);
          },
        });
        patchSendspinPlayer(sendspinPlayer);
          if (typeof sendspinPlayer.setVolume === 'function') {
            const vol = inlineVolume?.valueAsNumber ?? 100;
            sendspinPlayer.setVolume(vol / 100);
          }
          await sendspinPlayer.connect();
          isConnected = true;
          autoConnectDone = true;
          setStatus('Ready (Sendspin)', true, false);
          const meta = sendspinPlayer?.metadata || sendspinPlayer?.payload?.metadata;
          if (meta?.progress) {
            const pos = typeof meta.progress.position === 'number' ? meta.progress.position : 0;
            const dur = typeof meta.progress.duration === 'number' ? meta.progress.duration : 0;
            setTiming(pos, dur);
          }
        } catch (err) {
          setStatus(`Sendspin error: ${err?.message || err}`, false, true);
          console.error('sendspin connect failed', err);
          if (autoConnectRequested && !autoConnectDone) {
            requestAutoConnect();
          }
        }
      };

      const zonesEl = document.getElementById('zoneSelect');

      function selectProtocolForZone(zoneId) {
        const z = zones.find((zone) => String(zone.id) === String(zoneId));
        if (!z) {
          currentProtocol = 'snapcast';
          return;
        }
        const hasSnapcast =
          Array.isArray(z.transports) &&
          z.transports.some((t) => {
            const id = (t?.id || '').toLowerCase();
            return (
              id === 'snapcast' ||
              id === 'snapcast-cast' ||
              (id === 'googlecast' && (t && t.useSnapcast === true))
            );
          });
        const hasSendspin =
          Array.isArray(z.transports) &&
          z.transports.some((t) => {
            const id = (t?.id || '').toLowerCase();
            return (
              id === 'sendspin' ||
              id === 'sendspin-cast' ||
              (id === 'googlecast' && (t && t.useSendspin === true))
            );
          });
        currentProtocol = hasSnapcast ? 'snapcast' : hasSendspin ? 'sendspin' : 'snapcast';
      }

      async function loadZones() {
        try {
          const res = await fetch('/admin/api/zones/states');
          if (!res.ok) throw new Error(`zones fetch ${res.status}`);
          const data = await res.json();
          const list = Array.isArray(data?.zones) ? data.zones : Array.isArray(data) ? data : [];
        const supportsWs = (z) =>
          Array.isArray(z?.transports) &&
          z.transports.some(
            (t) => {
              if (!t || typeof t.id !== 'string') return false;
                const id = t.id.toLowerCase();
                if (/(snapcast|sendspin)/i.test(id)) return true;
                if (id === 'googlecast' && (t.useSendspin || t.useSnapcast)) return true;
                return false;
              },
            );
          const withWs = list.filter((z) => supportsWs(z));
          zones = (withWs.length > 0 ? withWs : list).map((z) => ({
            id: z.id,
            name: z.name,
            transports: z.transports,
          }));
          zonesEl.innerHTML =
            zones.length === 0
              ? '<option value="">No zones available</option>'
              : zones
                  .map(
                    (z, idx) =>
                      `<option value="${z.id}" ${idx === 0 ? 'selected' : ''}>${z.name} (id ${z.id})</option>`,
                  )
                  .join('');
          if (zones.length > 0) {
            const hasPreset = presetZoneId && zones.some((z) => String(z.id) === presetZoneId);
            const selected = hasPreset ? presetZoneId : zoneSelect.value || String(zones[0].id);
            zoneSelect.value = selected;
            selectProtocolForZone(selected);
            if ((autoConnectRequested || hasPreset) && !autoConnectDone) {
              requestAutoConnect();
            }
          }
        } catch (err) {
          zonesEl.innerHTML = '<option value="">Zone fetch failed</option>';
        }
      }

      loadZones().finally(logDebug);
      logDebug();
      zoneSelect.addEventListener('change', () => {
        selectProtocolForZone(zoneSelect.value);
        logDebug();
      });
    })();
  </script>
</body>
</html>
